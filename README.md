# Структуры данных, которые в будущем могут понадобиться ~~(нет)~~

## Содержание
1. [Декартово дерево](#декартово-дерево)

## Декартово дерево
### Структура
```
|--treap-coorevo
   |--dd.cpp
   |--dd_unkey.cpp
```
### Описание
> ### dd.cpp - обычное Декартово дерево
  * `value` - приоритет вершины
  * `key` - ключ
  * `sum` - сумма поддерева (включая саму вершину)
  
 
Дерево сделано на операцию "сумма на отрезке".
  * `bool find(node* tr, int k)` - получает на вход дерево и ключ. Отвечает, есть ли вершина с таким ключом в дереве.
  * `pair<node*, int> sum(node* tr, int l, int r)` - получает на вход дерево и отрезок [l, r]. Возвращает сумму на отрезке [l, r]. Отрезок относительно ключей, НЕ приоритетов.
  * `node* insert(node *tr, node* k)` - получает на вход дерево и вершину. Вставляет вершину в дерево. Возвращает получившееся дерево.
  * `pair<node *, node *> split(node *tr, int k)` делит дерево *tr* на два дерева. В левом все ключи `<k`, в правом все остальные. Возвращает пару этих деревьев.
  * `node *merge(node *tr1, node *tr2)` - сливает два дерева. `!ACHTUNG!` у *tr1* все ключи меньше (или равны?) ключей *tr2*.
  * `void update(node *n)` - обновляет информацию в вершине *n*.
  
todo - куча на минимум или максимум?
